# 按之字形顺序打印二叉树
## 题目：
>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，
第二层按照从右到左的顺序打印，即第一行按照从左到右的顺序打印，第二层按照从右到左顺序打印，
第三行再按照从左到右的顺序打印，其他以此类推。

## 解题思路
>按之字形顺序打印二叉树需要两个栈（使用LinkedList模拟栈）。
我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。
如果当前打印的是正向(使用flag控制，左到右 true)，则先保存左子结点再保存右子结点到一个栈里；
如果当前打印的是反向(使用flag控制，右到左 false)，则先保存右子结点再保存左子结点到第二个栈里。
如果当前层打印完，则交换下一层节点列表和当前层节点列表，同时翻转flag。

# 常见的7种单例写法

##  分类
1. 分为懒汉式;
2. 饿汉式;
3. 枚举式;
4. 静态内部类;

## 多线程安全与否
> 除了一种简单的饿汉式不使用同步锁，线程不安全之外别的安全，使用单次同步锁的一种单例有效率问题（多线程调用，
每个都会锁住然后操作）。


# 二维数组的搜索

## 题目
> 一个二维数组，要求查找一个目标对象是否在二维数组中。 

二维数组的特点如下：
1. 每行对象的值从小到大排列
2. 每列对象的值从小到大排列
3. 如下：
```
    0| 1| 2
    3| 4| 5
    6| 7| 8
```
## 解法如下：
* 方法一：
 
  暴力查找： 直接遍历查找

* 方法二：

  直接从第一行开始每行使用二分法查找，相对暴力查找，只是对基础的查找进行了优化
  
 * 方法三：
 
    根据二维数组的特点可以先判断右上角和左下角的数据， 从数据的每次对比可以排除一行和一列的数据，
    相对于上面的二分查找可以更快的缩短区间。